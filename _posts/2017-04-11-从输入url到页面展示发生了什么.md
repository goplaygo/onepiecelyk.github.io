---
layout: post
title: 从输入url到页面展示发生了什么
date: 2017-04-11 
tags: 博客   
---

### 前言
之前面试总会被问到当我们输入url时经过了什么步骤，最近在看http协议相关的文章。看到一篇文章讲解的较为详细，就想着记录下来。

链接：[咸鱼老弟-博客园](www.cnblogs.com/xianyulaodi/p/6547807.html);


当我们输入url时一共经过了9步，然后会展示给我们页面上的内容
 - 1、输入地址
 - 2、浏览器查找域名的ip地址
 - 3、浏览器向web服务器发送一个HTTP请求
 - 4、服务器的永久重定向响应
 - 5、浏览器跟踪重定向地址
 - 6、服务器处理请求
 - 7、服务器返回一个HTTP响应
 - 8、浏览器显示html
 - 9、浏览器发送请求获取嵌入在html中的资源（图片、音频、视频、CSS、JS等）
 
总体过程如下：

#### 1、输入地址

<hr>

当我们开始在浏览器中输入网址时，浏览器已经开始智能匹配可得的url了，它会从历史记录，书签等地方，找到已经输入的字符串可能对应的url，然后智能提示，让你可以补全url地址。对于Google Chrome，它甚至可以从缓存中把网页展示出来。

#### 2、浏览器查找域名的IP地址

<hr>

1、请求一旦发起，浏览器首先要做的是解析域名，一般来说，浏览器会首先查看本地硬盘的hosts文件，查看其中有没有与这个域名对应的规则，如果有则直接使用hosts里的ip地址

2、如果在本地hosts文件里的未找到对应的ip地址，浏览器会发出一个DNS请求到本地的DNS服务器。本地DNS服务器一般都是你的网络接入服务器商提供，如中国电信，中国联通。

3、查询你输入的DNS请求到达本地DNS服务器之后，本地DNS服务器会先查询它的缓存记录，如果缓存中包含此记录，则直接返回结果，在此过程中是递归的方式进行查询。若本地没有记录，则本地DNS服务器还要向DNS根服务器进行查询。

4、根DNS服务器没有记录的域名和IP地址的对应关系，而是告诉本地DNS服务器，你可以到域服务器上继续查询，并给出域服务器的地址。这种过称是迭代的过程。

5、本地DNS服务器继续向域服务器发出请求，而例如像.com域服务器，.com于服务器收到请求后，也不会直接返回和IP地址的对应关系，而是告诉本地DNS服务器，你的域名的解析服务器的地址。

6、最后，本地DNS服务器向域名的解析服务器发出请求，这时就能收到一个域名和IP地址对应关系，本地DNS服务器不仅要把IP地址返回给用户电脑，还要把这个对应关系保存到缓存中，以备下次使用，加快网络访问。

下面图片可以完美解释此过程：

![](/images/posts/170411/dns解析过程.png)

<div style="color:red;">知识扩展</div>

1）什么是DNS？

DNS（Domain Name System，域名系统），因特网上作为域名和IP地址互相映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住被机器直接读取的IP数串。通过主机名，最终得到改主机名对应的IP地址的过程叫做域名解析（或主机名解析）。

用更通俗的话来讲，我们通常习惯记住一个网站的名字，而不是它的ip地址，比如www.baidu.com,ip地址为167.23.10.2。而计算机更擅长记住网站的ip地址，而不像www.baidu.com等连接。因为，DNS就相当于一个电话本，比如你要找www.baidu.com这个域名，那我翻一翻我的电话本，就会知道它的电话（ip）是167.23.10.2。

2）DNS查询的两种方式：递归查询和迭代查询

1、递归查询

当局部DNS服务器自己不能回答客户机的DNS查询时，它就需要向其他DNS服务器进行查询。此时有两种方式，如图所示的是递归方式。局部DNS服务器自己负责向其他DNS服务器进行查询，一般是先向该域名的根域服务器查询，再由根域名服务器一级级像下查询。最后得到查询结果返回给局部DNS服务器，再由局部DNS服务器返回给客户端。

![](/images/posts/170411/递归解析.png)

2、迭代解析

当局部DNS服务器自己不能回答客户机的DNS查询时，也可以通过迭代查询的方式进行解析，如图所示，局部DNS服务器不是自己向其他DNS服务器查询，而是把能解析改域名的其他DNS服务器的ip地址返回给客户端DNS程序，
客户端DNS程序再继续向这些DNS服务器进行查询。直到查询到结果为止。也就是说，迭代解析只是帮你找到相关的服务器而已，而不会帮你去查。比如说：baidu.com的服务器ip地址为192.168.4.5这里，你自己去查询吧，本服务器比较忙，只能帮你到这了。

![](/images/posts/170411/迭代解析.png)

3）DNS域名名称空间的组织方式

我们在前面说的根DNS服务器，域DNS服务器，这些都是DNS域名称空间的组织方式。按照功能命名空间中用来描述DNS域民称的五个类别的介绍如下图所示：

![](/images/posts/170411/域名讲解.png)

4）DNS负载均衡

当一个网站有足够多的用户时，如果每次请求的资源都位于同一台机器上面，那么这台机器随时都会崩掉。我们的解决办法就是使用DNS负载均衡技术，它的原理是在DNS服务器中为同一个主机名配置多个IP地址，在应答DNS查询时，DNS服务器对每个查询将以DNS文件中主机记录的IP地址按顺序返回不同的解析结果，将客户端的访问引导到不同的机器上去，使得不同的客户端访问不同的服务器，从而达到负载均衡的目的。例如可以根据每台机器的负载量，该机器离用户地理位置的距离等。

#### 3、浏览器向web服务器发送一个HTTP请求

<hr>

当拿到域名对应的IP地址之后，浏览器会以一个随机端口（ 1024<端口<65535 ）向服务器的web程序（常用为httpd，nginx等）80端口发起TCP的链接请求。这个连接请求到达服务器后（中间通过各种路由设备，局域网内除外），进入到网卡，然后是进入到内核的TCP/IP协议栈（用于识别链接请求，解封包，一层一层的剥开），还可以会经过防火墙的过滤，最终达到web程序，最终建立一个TCP/IP链接。
TCP链接如图所示：

![](/images/posts/170411/TCP连接.png)

当建立TCP链接后，会发送第一个HTTP请求。一个http request header 一般包括请求的方法，例如GET或者POST等，还有些不常用的PUT和DELET，HEAD，OPTION以及TRACE方法，一般的浏览器只能发起GET或者POST请求。

客户端向服务端发起http请求的时候，会有一些请求信息，请求信息包括三个部分：

 - 请求方法URI协议/版本
 - 请求头（Request Header）
 - 请求正文

如下为一个完整的HTTP请求的例子：

GET/sample.jspHTTP/1.1  
Accept:image/gif.image/jpeg,*/*   
Accept-Language:zh-cn   
Connection:Keep-Alive   
Host:localhost   
User-Agent:Mozila/4.0(compatible;MSIE5.01;Window NT5.0)   
Accept-Encoding:gzip,deflate   

username=xxx&password=1234

由此可以看出最后一个请求头后是一个空行，发送回车符和换行符，通知服务器不再有请求头

（1）请求第一行是"方法URL协议/版本"：GET/sample.jspHTTP/1.1

（2）请求头（Request Header）

请求头包括许多有关客户端和请求正文的有用信息，如请求头可以声明浏览器所用的语言和请求正文的长度
 
 Accept:image/gif.image/jpeg,*/*   
 Accept-Language:zh-cn   
 Connection:Keep-Alive   
 Host:localhost   
 User-Agent:Mozila/4.0(compatible;MSIE5.01;Window NT5.0)   
 Accept-Encoding:gzip,deflate
 
 （3）请求正文

请求头和请求正文之间有一个空行，这个行非常重要，它表示请求头已经结束，接下来是请求正文。如下：

username=xxx&password=1234

##### 知识扩展

  1） TCP三次握手
  
  第一次握手：客户端A将标志位SYN置为1，随机产生一个seq=j（j的取值为1234567）的数据包到服务器，客户端A进入SYN_SENT状态，等待服务器B确认；
  
  第二次握手：服务器端B收到数据包后由标志位SYN=1知道A请求建立连接接，服务器B将标志位SYN和ACK都置为1，ack=j+1，随机产生一个值seq=K,并将改数据包发送给客户端A以确认连接请求，服务端B进入SYN_RCVD状态
  
  第三次握手：客户端A收到确认后，检查ack是否为j+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=k+1,并将改数据包发送给服务端B,服务端B检查ack是否为k+1，ACK是否为1，如果正确则连接建立成功，客户端A和客户端B进入ESTABLISHED状态，完成三次握手，随后客户端A与服务端B之间可以传输数据了。
  
  ![](/images/posts/170411/三次握手.png)
  
  2）为什么要三次握手？
  
  《计算机网络》第五版讲"三次握手"的目的是"为了防止已失效的链接请求报文突然又传输到了服务器，因而产生错误"
  
  3）四次挥手
  
  第一次挥手：客户端发送一个FIN，用来关闭客户端到服务端的数据传输，服务端进入FIN_WAIT_1状态。
  
  第二次挥手：服务端收到FIN后，发送一个ACK给客户端，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），服务端进入CLOSE_WAIT状态。
  
  第三次挥手：服务端发送一个FIN，用来关闭服务端到客户端数据传输，服务端进入LAST_ACK状态。
  
  第四次挥手：客户端收到FIN后，进入TIME_WAIT状态，接着发送一个ACK给服务端，确认号为收到序号+1，服务端进入CLOSE状态，完成四次挥手。
  
![](/images/posts/170411/四次握手.png)

  4）为什么建立连接是三次握手而关闭连接是四次挥手
  
  主要是因为服务端在LISTEN状态下，收到建立请求的SYN报文后，把ACK和SYN**放在一个报文里**发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了，但是还能接受数据，已方也未必全部数据都发送给对方了，所以已方可以立刻close，也可以发送一些数据给对方后，再发送FIN报文给对方表示同意现在关闭连接，因此，ACK和FIN一般会分开发送。
  
#### 4、服务器的永久重定向响应

<hr>

服务器给浏览器响应一个301永久重定向响应，这样浏览器会访问"https://www.google.com/"而非"https://google.com"。

为什么服务器一定要重定向而不是直接发送用户想看的网页内容呢？其中一个原因跟搜索引擎排名有关。如果一个页面有两个地址，就像https://www.yy.com和https://yy.com，搜索引擎会认为他们是两个网站，结果造成每个搜索链接都减少从而降低排名。而搜索引擎知道301永久重定向是什么意思，这样会把访问带www和不带www的地址都归到一个网站排名下。还有就是用不同的地址会造成缓存友好性变差，当一个页面有好几个名字时，它可能会在缓存中出现好几次。
  
 <div style="color:red;">扩展知识</div>
 
 1) 301和302的区别
 
 301和302状态码都是表示重定向，就是说浏览器在拿到服务器返回的状态码会自动跳转到一个新的url地址，这个地址可以从响应的Location首部中获取（用户看到的效果就是他输入的地址A瞬间变成另一个地址B）
 
 他们的不同在于，301表示旧地址A的资源已经被永久地移除了（这个资源不可访问），**搜索引擎在抓取新内容的同时也将旧内容的网址交换为重定向之后的网址**；
 
 302表示旧地址A的资源还在（仍然可以访问），这个重定向只是临时地从旧地址A跳转到地址B，**搜索引擎会抓取新的内容而保存旧的网址。所以SEO302好于301**
 
 2）重定向原因：
 
 （1）网站调整（如改变了网页目录结构）
 （2）网页被移到另一个新地址
 （3）网页扩展名改变（如.php改为了.html或.shtml）
 所以在这种情况下不做重定向，则用户收藏夹或搜索数据库中的旧地址只能让访问客户得到一个404页面错误信息，访问流量白白丧失；再者某些注册了多个域名的网站，也需要通过重定向让访问这些域名的用户自动跳转到主站点等。
 
  3）什么时候进行302或者301跳转
  
  当一个网站或者网页24-48小时内临时移动到一个新的位置，这时可以进行302跳转，而使用301跳转的场景则是之前的网站因为某种原因需要移除掉，然后要到新的地址访问，是永久性的。

#### 5、浏览器跟踪重定向地址

<hr>

当浏览器知道了"https://www.google.com/"才是要正确访问的地址，所以会发送一个http请求，返回。

#### 6、服务器处理请求

<hr>
 
经过前面的重重步骤，我们终于将我们的http请求发送到了服务器这里，其实之前的重定向已经到达服务器里了，那么，服务器是如何处理我们的请求呢？

后端在固定的端口接受到TCP报文开始，它会对TCP连接进行处理，对HTTP协议进行解析，并按照报文格式进一步封装成 HTTP Request对象，供上层使用。

对于一些大的网站将你的请求到烦向代理服务器中，因为当网站访问量非常大，网站越来越慢，一台服务器已经不够用了，于是将同一个应用部署到多台服务器上，将大量用户请求分配给多台机器处理。此时，客户端不是直接通过HTTP协议访问某网站应用服务器，而是先请求到Nginx，Nginx再请求应用服务器，然后将结果返回给客户端，这里Nginx的作用就是反向代理服务器。与此同时带来了一个好处，当其中一台服务器挂了，只要其他服务器正常运行，就不会影响用户使用。

如图所示：

![](/images/posts/170411/服务器处理请求.png)

通过Nginx的反向代理，我们达到了web服务器，服务器脚本处理我们的请求，访问我们数据库，获取需要获取的内容。

<div style="color:red">扩展阅读：</div>

1）什么反向代理？

客户端本来可以直接通过HTTP协议访问某网站应用服务器，网站管理员可以在中间加上一个Nginx，客户端请求Nginx，Nginx请求服务器，然后将结果返回客户端，此时Nginx就是反向代理服务器。

![](/images/posts/170411/服务器处理请求.png)

#### 7、服务器返回一个HTTP响应

<hr>

经过前面6个步骤，服务器收到了我们的请求，也处理我们的请求，到这一步，它会把它的处理结果返回，也就是返回一个HTTP响应。

HTTP响应与HTTP请求相似，HTTP响应也是由3部分组成，分别是：

- 状态行
- 响应头
- 响应正文

HTTP/1.1 200 OK   
Date: Sat, 31 Dec 2016 23:59:59 GMT   
Content-Type: text/html;charset=ISO-8859-1   Content-Length: 122   ＜html＞   
＜head＞   
＜title＞http＜/title＞   
＜/head＞   
＜body＞   
＜!-- body goes here --＞   
＜/body＞   
＜/html＞

1）状态行：

状态行由**协议版本、数字形式的状态代码、以及相应的状态描述，各元素之间以空格分隔**。

格式: HTTP-Version Status-Code Reason-PhraseCRLF

例如: HTTP/1.1 OK \r\n

--**协议版本**：用的是http的版本

--**状态描述**: 状态描述给出了状态代码的简单的文字描述。例如状态码200位成功

--**状态代码**： 状态代码有三位数组成，第一个代表响应的类别，有5种值，如下：

1XX：信息状态码，表示服务器已经接收了客户端的请求，客户端可以继续发送请求

 100 Continue

 101 SwitchingProtocols

2XX：成功状态码，表示服务器已经成功收到请求并进行处理。

 200 OK客户端请求成功

 204 No Content 成功，但不返回任何实体的主体部分
 
 206 Parital Content 成功执行了一个范围（Range）请求
 
3XX：重定向状态码，表示服务器要求客户端重定向
  
 301 Moved Permanently 永久重定向，响应报文的Location首部应该有该资源的新URL
 
 302 Found 临时重定向，响应报文的Location首部给出的URL用来临时定位资源
 
 303 See Other 请求的资源存在着另一个URI，客户端应使用GET方法定向获取请求资源

 304 Not Modified 服务器内部没有更新，可以直接读取浏览器缓存
 
 307 Temporary Redirect 临时重定向。与302 Found 一样。302禁止POST改为GET，但是实际使用时并不一定，307则更多浏览器会遵循这一标准，但也依赖浏览器实现
 
4XX：客户端错误状态码，表示客户端的请求有非法内容

 400 Bad Request 表示客户端请求有语法错误，不能被服务器所理解
 
 401 Unauthorized 表示未授权，改状态码必须与www-Authenticate报头域一起使用
 
 403 Forbidden 表示服务器收到请求，但是拒绝提供服务，通常会在响应正文中给出不提供服务的原因
 
 404 Not Found 请求的资源不存在，例如，输入了错误的URl
 
5XX：服务器错误状态码，表示服务器未能正常处理客户端的请求而出现意外错误

 500 Internel Server Error 表示服务器发生不可预期的错误，导致无法完成客户端的请求
 
 503 Service Unavailable 表示服务器当前不能够处理客户端错误的请求，在一段时间后，服务器可能会恢复正常
 
**响应头**：

*响应头部：由关键字/值对组成，每行一对，关键字和值用英文冒号"："分开，典型的响应头有*：

![](/images/posts/170411/响应头.png)

**响应正文**

包含我们需要的一些信息，比如cookie，html，image，后端返回的请求数据等。这里需要注意的是，响应正文和响应头之间有一行空格，比欧式响应头的信息到空格为止，下图为fiddle抓到的请求正文：

![](/images/posts/170411/相应正文.png)

#### 8、浏览器显示HTML

<hr>

在浏览器没有完全接受HTML文档时，他就开始显示这个页面了，浏览器是如何把页面展示在屏幕上呢，下面我们以谷歌浏览器的内核渲染过程展示：

解析html以构建dom树 -> 构建render树 -> 布局render树 -> 绘制render数

![](/images/posts/170411/浏览器解析html.png)

浏览器在解析html文件时，会"自上而下"加载，并在加载过程中进行解析渲染。在解析过程中，如果遇到请求的外部资源时，如图片，css，js，iconfont时，请求是异步的，并不会影响html文档加载

解析过程中，浏览器首先会解析HTML文件构建DOM树，然后解析CSS文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。这个过程比较复杂，涉及两个概念：reflow（回流）和repain（重绘）

DOM节点在各个元素都是以盒模型的形式存在，这些都是需要浏览器去计算位置和大小等，这个过程称为reflow；当盒模型的位置，大小以及其他属性，如颜色，字体确定下来之后，浏览器便开始绘制内容，这个过程称为repain。

首页在首次加载时必然会经历reflow和repain。reflow和repain过程是非常消耗性能的，尤其是在移动设备上，她会破坏用户体验，有时会造成页面卡。因此我们要尽可能的减少reflow和repain。



当文档加载过程中遇到了js文件，html文档会挂起渲染（加载解析渲染同步）的线程，不仅要等待文档中js文件加载完毕，还要等待解析完毕，才可以恢复html文档的渲染过程。因此JS会修改DOM，最经典的document.write，这意味着，在JS执行完毕前，后续所有的资源可能没有必要，这是js阻塞后续资源下载的根本原因。所以，js是放到html文档末尾的。

JS的解析是由浏览器的JS解析引擎完成的，比如谷歌的V8.JS是单线程运行，也就是说，在同一时期内只能做一件事，所有的任务都需要排队，前一个任务结束后，后一个任务才开始。但是又存在某些任务比较耗时，如IO读写等，所以需要一种机制可以执行排在后面的任务，这就是：同步任务和异步任务。

JS的执行机制就是可以看做是一个主线程加上一个任务队列，同步任务就是放在主线程上执行的任务，异步任务是放在任务队列中的任务。所有的同步任务在主线程上执行，形成一个执行栈；异步任务有了运行结果就会放到任务队列中放置一个事件；脚本运行时先依次运行执行栈，然后会从任务队列里提取事件，运行任务队列的任务，这个过程是不断重复的，所以又叫做事件循环。

![](/images/posts/170411/JS%20runtime.png)

#### 9、浏览器发送请求获取嵌入在HTML中的资源（如图片，音频，视频，CSS，JS等）

这个步骤可以并列在第八步中，在浏览器显示HTML时，他会注意到需要获取的其他地址内容的标签。这时浏览器会发送一个获取请求来重新获取这些文件。例如我们要获取的一些图片，css，js

图片：http://dwz.cn/5K6SvC；

CSS：http://static.ak.fbcdn.net/rsrc.php/z448Z/hash/2plh8s4n.css

JS：http://static.ak.fbcdn.net/rsrc.php/zEMOA/hash/c8yzb6ub.js

当然这些过程任然经历和html读取类似的过程。所以浏览器会DNS中查找这些域名，发送请求，重定向等等。

不想动态页面，静态文件会允许浏览器进行缓存。有点文件可能会不需要与服务器通讯，而从缓存中直接读取，或者可以放到CDN中


参考文献：

https://segmentfault.com/a/1190000006879700  

http://igoro.com/archive/what-really-happens-when-you-navigate-to-a-url/

http://zrj.me/archives/589 




